#!/bin/sh

set -euo pipefail

cronPid=0
serverPid=0
firstUpdatePid=0

# gracefully handlei SIGINT and SIGTERM
term_handler() {
    set +e
    echo "Terminating..."

    if [ $firstUpdatePid -ne 0 ]; then
        echo "Ending firstUpdate..."
        kill -SIGTERM "$firstUpdatePid"
        wait $firstUpdatePid
        echo "firstUpdate ended."
    fi

    if [ $cronPid -ne 0 ]; then
        echo "Ending cron..."
        kill -SIGTERM "$cronPid"
        wait $cronPid
        echo "Cron ended."
    fi

    if [ $serverPid -ne 0 ]; then
        echo "Ending server..."
        kill -SIGTERM "$serverPid"
        wait $serverPid
        echo "Server ended."
    fi

    exit 143
}

trap 'term_handler' SIGTERM
trap 'term_handler' SIGINT

# Start go-exploitdb server listening and setup/migrate exploit db file
echo "Starting server listening on 0.0.0.0:1326..."
go-exploitdb server --bind 0.0.0.0 --dbpath /vuls/go-exploitdb.sqlite3 &
serverPid=$!

# Wait until the server is up and running healthy and can respond to a query
# before starting the updater to avoid migration conflicts between the server
# command and the updating commands.
# TODO(sambetts) use curl here if we can get it installed in the container
sleep 5

# Run update once on container start to ensure we're up to date.
/update.sh &
firstUpdatePid=$!
wait $firstUpdatePid
firstUpdatePid=0

# Start cron in the background which will run the updater script periodically,
echo "Starting periodic updates..."
crond -f &
cronPid=$!

# Wait on Server PID to complete, if it ends then terminate
wait $serverPid

# Clean up everything
term_handler
